<!DOCTYPE html>
<html lang="zh-Hant">
<head>
  <meta charset="UTF-8">
  <title>殺手數獨（V17升級：白底高亮、三錯提示、填滿選項消失）</title>
  <style>
    body { font-family: sans-serif; }
    .board {
      display: grid;
      grid-template-columns: repeat(9, 40px);
      gap: 0px;
      width: fit-content;
      margin: 30px auto 10px;
      border: 4px solid #222;
    }
    .cell {
      position: relative;
      width: 40px;
      height: 40px;
      border: 1px solid #aaa;
      text-align: center;
      font-size: 20px;
      background: #fff;
      cursor: pointer;
      box-sizing: border-box;
      overflow: hidden;
      display: flex;
      align-items: center;
      justify-content: center;
      user-select: none;
      transition: background 0.15s;
    }
    .cell.selected { border: 2px solid #2196f3; background: #e3f2fd; }
    .cell.hilight { background: #fff !important; }
    .sum-label {
      position: absolute;
      top: 2px; left: 2px;
      font-size: 10px; color: #333;
      pointer-events:none;
      z-index: 3;
      background: inherit;
      padding: 1px 2px;
      border-radius: 5px;
    }
    .pre-fill { color: #00796b; font-weight: bold; z-index: 4; }
    .number-pad { display: flex; justify-content: center; gap: 8px; margin-top: 14px; }
    .num-btn { width: 34px; height: 34px; font-size: 20px; border: 1px solid #2196f3; border-radius: 6px; background: #f5f5f5; cursor: pointer; }
    .num-btn.inactive { opacity:0.25; pointer-events:none;}
    .num-btn:hover { background: #2196f3; color: white; }
    .num-btn.del { border: 1px solid #f44336; color: #f44336; }
    .num-btn.del:hover { background: #f44336; color: white; }
    #note-toggle { font-size:15px; margin-left:12px; padding:4px 10px; border-radius:5px; border:1px solid #2196f3; background:#e3f2fd; color:#1565c0; cursor:pointer;}
    #note-toggle.active { background:#2196f3; color:#fff; }
    .cage-border-inner {
      position: absolute;
      pointer-events:none;
      z-index: 2;
      box-sizing: border-box;
      left: 5px; top: 5px; right: 5px; bottom: 5px;
      border: none;
    }
    .cell-value {
      width: 100%;
      height: 100%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 20px;
      z-index: 4;
      position: relative;
    }
    .cell-value.error {
      color: #f44336;
      font-weight: bold;
    }
    .notes {
      position: absolute;
      width: 100%;
      height: 100%;
      left: 0; top: 0;
      z-index: 3;
      display: grid;
      grid-template-columns: repeat(3,1fr);
      grid-template-rows: repeat(3,1fr);
      font-size: 9px;
      color: #888;
      pointer-events:none;
      align-items: center;
      justify-items: center;
    }
    #control-bar {
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 10px;
      margin-top: 16px;
      margin-bottom: 0;
    }
    #pre-fill-input {
      width: 50px;
      font-size: 16px;
      text-align: center;
      padding: 2px 6px;
      border-radius: 4px;
      border: 1px solid #aaa;
    }
    button#new-btn {
      font-size: 18px;
      padding: 6px 16px;
      background: #2196f3;
      border: none;
      color: white;
      border-radius: 6px;
      cursor: pointer;
      transition: background 0.2s;
    }
    button#new-btn:hover { background: #1565c0; }
    #finish-mask {
      position: fixed;
      left:0; top:0; right:0; bottom:0;
      background: rgba(255,255,255,0.8);
      z-index: 99;
      display: flex;
      align-items: center;
      justify-content: center;
      animation: fadeIn 0.4s;
    }
    #finish-msg {
      font-size: 40px;
      font-weight: bold;
      color: #43a047;
      text-align: center;
      background: linear-gradient(90deg,#fa709a,#fee140,#43e97b 80%);
      background-clip: text;
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      animation: rainbow 1.2s linear infinite;
    }
    @keyframes fadeIn {
      from { opacity:0; }
      to { opacity:1; }
    }
    @keyframes rainbow {
      0%{ filter:hue-rotate(0deg); }
      100%{ filter:hue-rotate(360deg);}
    }
    #error-modal {
      position: fixed;
      left: 0; top: 0; right: 0; bottom: 0;
      background: rgba(0,0,0,0.35);
      z-index: 100;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    #error-modal-inner {
      background: #fff;
      border-radius: 12px;
      box-shadow: 0 2px 12px rgba(0,0,0,0.2);
      padding: 32px 36px;
      text-align: center;
      font-size: 22px;
      color: #1565c0;
    }
    #error-modal-inner button {
      margin-top: 18px;
      font-size: 18px;
      padding: 8px 22px;
      background: #2196f3;
      border: none;
      color: white;
      border-radius: 6px;
      cursor: pointer;
      transition: background 0.2s;
    }
    #error-modal-inner button:hover { background: #1565c0; }
  </style>
</head>
<body>
  <h1>殺手數獨（白底高亮＋三錯提示＋填滿選項消失）</h1>
  <div id="control-bar">
    <label>預填格數 <input id="pre-fill-input" type="number" min="10" max="81" value="25"></label>
    <button id="new-btn">產生新題目</button>
    <button id="note-toggle">筆記模式</button>
  </div>
  <div class="board" id="sudoku-board"></div>
  <div class="number-pad" id="number-pad" style="display:none;"></div>
  <div id="finish-mask" style="display:none;">
    <div id="finish-msg">🎉 完成！ 🎉</div>
  </div>
  <div id="error-modal" style="display:none;">
    <div id="error-modal-inner">
      錯誤次數已達3次<br>要重新開始嗎？<br>
      <button id="error-restart-btn">重新開始</button>
    </div>
  </div>
</body>
<script>
  const STORAGE_KEY = "killer_sudoku_save";
  const cageColors = [
    "#ffe5cc", "#ccffcc", "#cce5ff", "#ffd9e6", "#e5ccff", "#ffffcc",
    "#d9e6ff", "#ffcccc", "#ccffe5", "#e6ffd9", "#f5f5dc", "#e0f7fa", "#ffe4e1"
  ];

  let PRE_FILL_NUM = 25;
  let answerGrid, cages, preFills, cellValues, preFillMap, cellNotes;
  let noteMode = false;
  let selectedCell = null;
  let errorCount = 0;

  function is9x9Array(arr) {
    return Array.isArray(arr) && arr.length === 9 && arr.every(row => Array.isArray(row) && row.length === 9);
  }

  function safeLoadFromStorage() {
    const raw = localStorage.getItem(STORAGE_KEY);
    if(!raw) return false;
    try {
      const data = JSON.parse(raw);
      if (!is9x9Array(data.cellValues) ||
          !is9x9Array(data.cellNotes) ||
          !is9x9Array(data.preFillMap) ||
          !is9x9Array(data.answerGrid) ||
          !Array.isArray(data.cages) ||
          !Array.isArray(data.preFills)) return false;
      answerGrid = data.answerGrid;
      cages = data.cages;
      preFills = data.preFills;
      cellValues = data.cellValues;
      preFillMap = data.preFillMap;
      cellNotes = data.cellNotes;
      PRE_FILL_NUM = data.PRE_FILL_NUM || 25;
      errorCount = data.errorCount || 0;
      document.getElementById("pre-fill-input").value = PRE_FILL_NUM;
      selectedCell = null;
      return true;
    } catch(e) {
      return false;
    }
  }

  function saveToStorage() {
    const data = {
      answerGrid,
      cages,
      preFills,
      cellValues,
      preFillMap,
      cellNotes,
      PRE_FILL_NUM,
      errorCount
    };
    localStorage.setItem(STORAGE_KEY, JSON.stringify(data));
  }

  function generateSudoku() {
    const grid = Array.from({length:9},()=>Array(9).fill(0));
    const nums = [1,2,3,4,5,6,7,8,9];
    function shuffle(arr) {
      for(let i=arr.length-1;i>0;i--){
        const j=Math.floor(Math.random()*(i+1));
        [arr[i],arr[j]]=[arr[j],arr[i]];
      }
    }
    function fill(r=0,c=0) {
      if(r==9) return true;
      if(c==9) return fill(r+1,0);
      shuffle(nums);
      for(const v of nums) {
        if(valid(r,c,v)) {
          grid[r][c]=v;
          if(fill(r,c+1)) return true;
          grid[r][c]=0;
        }
      }
      return false;
    }
    function valid(r,c,v){
      for(let i=0;i<9;i++)
        if(grid[r][i]==v||grid[i][c]==v) return false;
      const br=Math.floor(r/3)*3,bc=Math.floor(c/3)*3;
      for(let i=0;i<3;i++) for(let j=0;j<3;j++)
        if(grid[br+i][bc+j]==v) return false;
      return true;
    }
    fill();
    return grid;
  }

  function generateCages(grid) {
    const marked = Array.from({length:9},()=>Array(9).fill(false));
    const cages = [];
    const directions = [[0,1],[1,0],[0,-1],[-1,0]];
    while(true){
      let found=false;
      for(let r=0;r<9&&!found;r++)
        for(let c=0;c<9&&!found;c++)
          if(!marked[r][c]) {
            found=true;
            let size = Math.floor(Math.random()*3)+2;
            const cageCells=[[r,c]];
            marked[r][c]=true;
            for(let k=1;k<size;k++){
              let candidates=[];
              for(const [cr,cc] of cageCells){
                for(const [dr,dc] of directions){
                  let nr=cr+dr,nc=cc+dc;
                  if(nr>=0&&nr<9&&nc>=0&&nc<9&&!marked[nr][nc]){
                    candidates.push([nr,nc]);
                  }
                }
              }
              if(candidates.length){
                const [nr,nc]=candidates[Math.floor(Math.random()*candidates.length)];
                cageCells.push([nr,nc]);
                marked[nr][nc]=true;
              }
            }
            let sum = cageCells.reduce((a,[r,c])=>a+grid[r][c],0);
            cages.push({sum:sum,cells:cageCells});
          }
      if(!found) break;
    }
    return cages;
  }

  function assignCageColors(cages) {
    function getCageIdMap(cages) {
      const map = Array.from({length:9},()=>Array(9).fill(-1));
      cages.forEach((cage, idx) => cage.cells.forEach(([r,c]) => map[r][c]=idx));
      return map;
    }
    const map = getCageIdMap(cages);
    const cageAdj = cages.map(()=>new Set());
    cages.forEach((cage, idx) => {
      cage.cells.forEach(([r,c]) => {
        [[0,1],[1,0],[0,-1],[-1,0]].forEach(([dr,dc])=>{
          let nr=r+dr,nc=c+dc;
          if(nr>=0&&nr<9&&nc>=0&&nc<9){
            let nId = map[nr][nc];
            if(nId!==idx && nId!==-1) cageAdj[idx].add(nId);
          }
        });
      });
    });
    const cageColorIdx = [];
    for(let i=0;i<cages.length;i++){
      let used = new Set();
      for(const adj of cageAdj[i]) {
        if(typeof cageColorIdx[adj]==="number") used.add(cageColorIdx[adj]);
      }
      let pick = 0;
      while(used.has(pick)) pick++;
      cageColorIdx[i]=pick % cageColors.length;
    }
    cages.forEach((cage, idx) => cage.color = cageColors[cageColorIdx[idx]]);
    return cages;
  }

  function getPreFilled(grid, num) {
    const all = [];
    for(let r=0;r<9;r++) for(let c=0;c<9;c++) all.push([r,c]);
    for(let i=all.length-1;i>0;i--){
      const j=Math.floor(Math.random()*(i+1));
      [all[i],all[j]]=[all[j],all[i]];
    }
    return all.slice(0,num).map(([r,c])=>({r,c,value:grid[r][c]}));
  }

  function getCageId(r,c) {
    for(let i=0;i<cages.length;i++)
      if(cages[i].cells.some(([rr,cc])=>rr===r&&cc===c)) return i;
    return -1;
  }

  function getCageInnerBorders(r, c, cage) {
    let borders = {};
    if(!cage.cells.some(([rr,cc])=>rr===r-1&&cc===c)) borders.top=true;
    if(!cage.cells.some(([rr,cc])=>rr===r+1&&cc===c)) borders.bottom=true;
    if(!cage.cells.some(([rr,cc])=>rr===r&&cc===c-1)) borders.left=true;
    if(!cage.cells.some(([rr,cc])=>rr===r&&cc===c+1)) borders.right=true;
    return borders;
  }

  function getBoxBorders(r, c) {
    let borders = {};
    if(r%3===0) borders.top=true;
    if(r%3===2) borders.bottom=true;
    if(c%3===0) borders.left=true;
    if(c%3===2) borders.right=true;
    return borders;
  }

  function getErrorCells(cellValues, answerGrid, preFillMap) {
    const errors = Array.from({length:9},()=>Array(9).fill(false));
    for(let r=0;r<9;r++) for(let c=0;c<9;c++)
      if(cellValues[r][c] && Number(cellValues[r][c]) !== answerGrid[r][c] && !preFillMap[r][c])
        errors[r][c]=true;
    return errors;
  }

  function isFinished(cellValues, answerGrid, preFillMap) {
    for(let r=0;r<9;r++) for(let c=0;c<9;c++) {
      if(!cellValues[r][c]) return false;
      if(!preFillMap[r][c] && Number(cellValues[r][c]) !== answerGrid[r][c]) return false;
    }
    return true;
  }

  function showFinishAnimation() {
    document.getElementById("finish-mask").style.display = "flex";
    setTimeout(()=> {
      document.getElementById("finish-mask").style.display = "none";
    }, 1800);
  }

  function showErrorModal() {
    document.getElementById("error-modal").style.display = "flex";
  }
  function hideErrorModal() {
    document.getElementById("error-modal").style.display = "none";
  }

  function getHighlightMap() {
    // 白底高亮：選中答案（預填/玩家填入）格時，同行/列/九宮格/同數字都高亮
    // 選中空格也高亮自己
    const map = Array.from({length:9},()=>Array(9).fill(false));
    if(selectedCell) {
      const [sr,sc] = selectedCell;
      const val = cellValues[sr][sc];
      if(val) {
        for(let i=0;i<9;i++) map[sr][i]=true;
        for(let i=0;i<9;i++) map[i][sc]=true;
        const br=Math.floor(sr/3)*3, bc=Math.floor(sc/3)*3;
        for(let r=br;r<br+3;r++) for(let c=bc;c<bc+3;c++) map[r][c]=true;
        for(let r=0;r<9;r++) for(let c=0;c<9;c++)
          if(cellValues[r][c]==val) map[r][c]=true;
      } else {
        map[sr][sc]=true;
      }
    }
    return map;
  }

  function getFilledNumberCounts() {
    // 統計各數字出現次數（只算預填和玩家填入，不含筆記）
    const counts = Array(10).fill(0);
    for(let r=0;r<9;r++) for(let c=0;c<9;c++) {
      const v = cellValues[r][c];
      if(v) counts[Number(v)]++;
    }
    return counts;
  }

  function newPuzzle(preFillNum) {
    PRE_FILL_NUM = preFillNum;
    answerGrid = generateSudoku();
    cages = assignCageColors(generateCages(answerGrid));
    preFills = getPreFilled(answerGrid, PRE_FILL_NUM);
    cellValues = Array.from({length:9},()=>Array(9).fill(''));
    preFillMap = Array.from({length:9},()=>Array(9).fill(false));
    cellNotes = Array.from({length:9},()=>Array.from({length:9},()=>[]));
    errorCount = 0;
    for(const {r,c,value} of preFills) {
      cellValues[r][c]=value;
      preFillMap[r][c]=true;
    }
    selectedCell = null;
    saveToStorage();
    renderBoard();
    document.getElementById("finish-mask").style.display = "none";
    hideErrorModal();
  }

  const board = document.getElementById('sudoku-board');

  function renderBoard() {
    const errorCells = getErrorCells(cellValues, answerGrid, preFillMap);
    const highlightMap = getHighlightMap();
    board.innerHTML = '';
    for(let r=0; r<9; r++) {
      for(let c=0; c<9; c++) {
        const cell = document.createElement('div');
        cell.className = 'cell';
        // 九宮格粗框
        const boxBorders = getBoxBorders(r,c);
        if(boxBorders.top) cell.style.borderTop = '1.5px solid #222';
        if(boxBorders.bottom) cell.style.borderBottom = '1.5px solid #222';
        if(boxBorders.left) cell.style.borderLeft = '1.5px solid #222';
        if(boxBorders.right) cell.style.borderRight = '1.5px solid #222';

        // 籠子底色
        let cageId = getCageId(r, c);
        if(cageId!==-1) cell.style.background = cages[cageId].color;

        if(selectedCell && selectedCell[0]===r && selectedCell[1]===c)
          cell.classList.add('selected');
        if(highlightMap[r][c]) cell.classList.add('hilight');

        // 籠子虛線框 (絕對定位，比格子小)
        if(cageId!==-1) {
          const borders = getCageInnerBorders(r,c,cages[cageId]);
          if(borders.top || borders.bottom || borders.left || borders.right) {
            const borderDiv = document.createElement('div');
            borderDiv.className = 'cage-border-inner';
            borderDiv.style.border = 'none';
            if(borders.top)    borderDiv.style.borderTop    = '1.5px dashed #888';
            if(borders.bottom) borderDiv.style.borderBottom = '1.5px dashed #888';
            if(borders.left)   borderDiv.style.borderLeft   = '1.5px dashed #888';
            if(borders.right)  borderDiv.style.borderRight  = '1.5px dashed #888';
            cell.appendChild(borderDiv);
          }
        }

        // 籠子加總標示
        cages.forEach((cage) => {
          const [cr,cc] = cage.cells[0];
          if(cr===r && cc===c) {
            const label = document.createElement('div');
            label.className = 'sum-label';
            label.innerText = cage.sum;
            cell.appendChild(label);
          }
        });

        // 筆記顯示
        if(cellNotes[r][c] && cellNotes[r][c].length>0 && !cellValues[r][c]) {
          const notes = document.createElement('div');
          notes.className = 'notes';
          for(let i=1;i<=9;i++) {
            const span = document.createElement('span');
            if(cellNotes[r][c].includes(i)) span.textContent = i;
            notes.appendChild(span);
          }
          cell.appendChild(notes);
        }
        // 數字（預填或玩家填入），用 .cell-value 包裹置中
        let numHtml = '';
        if(preFillMap[r][c]) {
          numHtml = `<span class="cell-value pre-fill">${cellValues[r][c]}</span>`;
        } else if(cellValues[r][c]) {
          numHtml = `<span class="cell-value${errorCells[r][c] ? ' error' : ''}">${cellValues[r][c]}</span>`;
        }
        cell.innerHTML += numHtml;

        cell.addEventListener('click', () => {
          selectedCell = [r,c];
          renderBoard();
          showNumberPad();
        });
        board.appendChild(cell);
      }
    }
    saveToStorage();
    if(isFinished(cellValues, answerGrid, preFillMap)) {
      showFinishAnimation();
    }
  }

  function showNumberPad() {
    const pad = document.getElementById('number-pad');
    pad.innerHTML = '';
    pad.style.display = selectedCell ? 'flex' : 'none';

    // 動態隱藏填滿的數字按鈕
    const counts = getFilledNumberCounts();
    for(let i=1;i<=9;i++) {
      const btn = document.createElement('button');
      btn.className = 'num-btn';
      btn.textContent = i;
      if(counts[i]>=9) btn.classList.add('inactive');
      btn.disabled = counts[i]>=9;
      btn.addEventListener('click', () => {
        if(selectedCell && counts[i]<9) {
          const [r,c] = selectedCell;
          if(noteMode) {
            if(!cellNotes[r][c]) cellNotes[r][c]=[];
            if(cellNotes[r][c].includes(i)) {
              cellNotes[r][c]=cellNotes[r][c].filter(x=>x!==i);
            } else {
              cellNotes[r][c].push(i);
              cellNotes[r][c].sort();
            }
            saveToStorage();
            renderBoard();
          } else {
            if(preFillMap[r][c]) return; // 預填格不可填答案
            if(Number(i)!==answerGrid[r][c]) {
              errorCount++;
              saveToStorage();
              if(errorCount>=3) {
                showErrorModal();
                return;
              }
            }
            cellValues[r][c] = i;
            cellNotes[r][c] = [];
            selectedCell = null;
            saveToStorage();
            renderBoard();
          }
        }
      });
      pad.appendChild(btn);
    }
    const delBtn = document.createElement('button');
    delBtn.className = 'num-btn del';
    delBtn.textContent = '清除';
    delBtn.addEventListener('click', () => {
      if(selectedCell) {
        const [r,c] = selectedCell;
        if(noteMode) {
          cellNotes[r][c] = [];
          saveToStorage();
          renderBoard();
        } else {
          if(preFillMap[r][c]) return; // 預填格不可清除
          cellValues[r][c] = '';
          saveToStorage();
          selectedCell = null;
          renderBoard();
        }
      }
    });
    pad.appendChild(delBtn);
  }

  document.getElementById("new-btn").onclick = () => {
    const n = parseInt(document.getElementById("pre-fill-input").value,10);
    let num = Math.max(10, Math.min(81, isNaN(n)?25:n));
    newPuzzle(num);
  };

  document.getElementById("note-toggle").onclick = () => {
    noteMode = !noteMode;
    document.getElementById("note-toggle").classList.toggle("active", noteMode);
    renderBoard();
  };

  document.getElementById("error-restart-btn").onclick = () => {
    const n = parseInt(document.getElementById("pre-fill-input").value,10);
    let num = Math.max(10, Math.min(81, isNaN(n)?25:n));
    newPuzzle(num);
  };

  // 若 localStorage 結構不符，強制初始化
  if(!safeLoadFromStorage()) {
    newPuzzle(PRE_FILL_NUM);
  } else {
    renderBoard();
  }
</script>
</html>
