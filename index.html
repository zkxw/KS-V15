<!DOCTYPE html>
<html lang="zh-Hant">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>æ®ºæ‰‹æ•¸ç¨</title>
  <style>
    body { font-family: sans-serif; margin: 0; padding: 8px; }
    .top-bar {
      display: flex;
      flex-direction: column;
      align-items: center;
      margin-bottom: 0;
      margin-top: 16px;
    }
    #status-bar {
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 20px;
      font-size: 17px;
      margin-bottom: 12px;
      font-weight: bold;
      color: #1565c0;
    }
    #control-bar {
      display: grid;
      grid-template-columns: 1fr 1fr;
      grid-template-rows: auto auto;
      gap: 10px;
      width: 100%;
      max-width: 500px;
      align-items: center;
      justify-items: center;
    }
    /* ç¬¬ä¸€è¡Œï¼šé å¡«æ ¼æ•¸ + ç”¢ç”Ÿæ–°é¡Œç›® */
    .prefill-group {
      display: flex;
      align-items: center;
      gap: 10px;
      font-size: 15px;
      color: #1565c0;
      font-weight: bold;
    }
    #pre-fill-input {
      width: 50px;
      font-size: 15px;
      text-align: center;
      padding: 6px;
      border-radius: 4px;
      border: 1px solid #aaa;
    }
    button#new-btn {
      font-size: 15px;
      padding: 8px 16px;
      background: #2196f3;
      border: none;
      color: white;
      border-radius: 6px;
      cursor: pointer;
      transition: background 0.2s;
      white-space: nowrap;
      min-width: 120px;
    }
    button#new-btn:hover { background: #1565c0; }
    
    /* ç¬¬äºŒè¡Œï¼šå››å€‹åŠŸèƒ½æŒ‰éˆ•æ©«æ’ */
    .function-buttons {
      grid-column: 1 / -1;
      display: flex;
      gap: 8px;
      width: 100%;
    }
    
    /* çµ±ä¸€æ‰€æœ‰åŠŸèƒ½æŒ‰éˆ•çš„æ¨£å¼ */
    #note-toggle, #toggle-normal, #pause-btn, #ranking-btn {
      flex: 1;
      font-size: 14px;
      padding: 8px 12px;
      border-radius: 6px;
      cursor: pointer;
      font-weight: bold;
      transition: all 0.2s;
      white-space: nowrap;
      border: none;
      height: 40px;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    
    /* ç­†è¨˜æŒ‰éˆ• */
    #note-toggle {
      background: #e3f2fd;
      color: #1565c0;
      border: 1px solid #2196f3;
    }
    #note-toggle.on {
      background: #2196f3;
      color: #fff;
      border: 1px solid #1565c0;
    }
    #note-toggle:hover {
      background: #2196f3;
      color: #fff;
    }
    
    /* æ™®é€šæ•¸ç¨æŒ‰éˆ• */
    #toggle-normal {
      background: #f7f7f7;
      color: #333;
      border: 1px solid #888;
    }
    #toggle-normal.active { 
      background: #ffe082; 
      color: #000; 
      border: 1px solid #fbc02d;
    }
    #toggle-normal:hover {
      background: #ffe082;
      color: #000;
    }
    
    /* æš«åœæŒ‰éˆ• */
    #pause-btn {
      background: #2196f3;
      color: white;
      border: 1px solid #1565c0;
    }
    #pause-btn:hover { 
      background: #1565c0; 
    }
    #pause-btn.paused {
      background: #f44336;
      border: 1px solid #d32f2f;
    }
    
    /* è¨ˆåˆ†æ¿æŒ‰éˆ• */
    #ranking-btn {
      background: #e0f2f1;
      color: #00796b;
      border: 1px solid #00796b;
    }
    #ranking-btn:hover {
      background: #00796b;
      color: white;
    }

    #timer {
      font-size: 18px;
      color: #d84315;
      font-weight: bold;
      background: #fffbe7;
      border-radius: 6px;
      padding: 3px 10px;
      border: 1.2px solid #ffcc80;
      box-shadow: 0 0 6px #ffe082;
      letter-spacing: 1px;
    }
    #error-count {
      background: #fffbe7;
      border-radius: 6px;
      padding: 3px 10px;
      border: 1.2px solid #2196f3;
      box-shadow: 0 0 6px #bbdefb;
    }
    
    .board {
      display: grid;
      grid-template-columns: repeat(9, 40px);
      gap: 0px;
      width: fit-content;
      margin: 10px auto 10px;
      border: 4px solid #222;
    }
    .cell {
      position: relative;
      width: 40px;
      height: 40px;
      border: 1px solid #aaa;
      text-align: center;
      font-size: 20px;
      background: #fff;
      cursor: pointer;
      box-sizing: border-box;
      overflow: hidden;
      display: flex;
      align-items: center;
      justify-content: center;
      user-select: none;
      transition: background 0.15s;
    }
    .cell.selected { border: 2px solid #2196f3; background: #e3f2fd; }
    .cell.hilight { background: #fff !important; }
    .sum-label {
      position: absolute;
      top: 2px; left: 2px;
      font-size: 10px; color: #333;
      pointer-events:none;
      z-index: 3;
      background: inherit;
      padding: 1px 2px;
      border-radius: 5px;
    }
    .pre-fill { color: #00796b; font-weight: bold; z-index: 4; }
    .number-pad { display: flex; justify-content: center; gap: 8px; margin-top: 14px; }
    .num-btn { width: 34px; height: 34px; font-size: 20px; border: 1px solid #2196f3; border-radius: 6px; background: #f5f5f5; cursor: pointer; }
    .num-btn.inactive { opacity:0.25; pointer-events:none;}
    .num-btn:hover { background: #2196f3; color: white; }
    .num-btn.del { border: 1px solid #f44336; color: #f44336; }
    .num-btn.del:hover { background: #f44336; color: white; }
    .cage-border-inner {
      position: absolute;
      pointer-events:none;
      z-index: 2;
      box-sizing: border-box;
      left: 5px; top: 5px; right: 5px; bottom: 5px;
      border: none;
    }
    .cell-value {
      width: 100%;
      height: 100%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 20px;
      z-index: 4;
      position: relative;
    }
    .cell-value.error {
      color: #f44336;
      font-weight: bold;
    }
    .notes {
      position: absolute;
      width: 100%;
      height: 100%;
      left: 0; top: 0;
      z-index: 3;
      display: grid;
      grid-template-columns: repeat(3,1fr);
      grid-template-rows: repeat(3,1fr);
      font-size: 11px;
      color: #1565c0;
      font-weight:bold;
      pointer-events:none;
      align-items: center;
      justify-items: center;
      background:rgba(255,255,255,0.55);
      border-radius:4px;
      box-shadow:0 0 3px #bbdefb;
    }
    #finish-mask, #error-modal, #result-modal, #ranking-modal {
      position: fixed;
      left:0; top:0; right:0; bottom:0;
      background: rgba(255,255,255,0.8);
      z-index: 110;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    #finish-mask { z-index: 99; }
    #finish-msg {
      font-size: 40px;
      font-weight: bold;
      color: #43a047;
      text-align: center;
      background: linear-gradient(90deg,#fa709a,#fee140,#43e97b 80%);
      background-clip: text;
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      animation: rainbow 1.2s linear infinite;
    }
    @keyframes rainbow {
      0%{ filter:hue-rotate(0deg); }
      100%{ filter:hue-rotate(360deg);}
    }
    #error-modal-inner, #result-modal-inner, #ranking-modal-inner {
      background: #fff;
      border-radius: 12px;
      box-shadow: 0 2px 12px rgba(0,0,0,0.2);
      padding: 32px 36px;
      text-align: center;
      font-size: 22px;
      color: #1565c0;
      min-width: 260px;
    }
    #result-modal-inner p {
      font-size: 20px;
      margin:12px 0 2px 0;
      color: #333;
    }
    #result-modal-inner .summary {
      font-size: 19px;
      color: #2196f3;
      margin-bottom: 14px;
    }
    #result-modal-inner button {
      margin-top: 18px;
      font-size: 18px;
      padding: 8px 22px;
      background: #2196f3;
      border: none;
      color: white;
      border-radius: 6px;
      cursor: pointer;
      transition: background 0.2s;
    }
    #result-modal-inner button:hover { background: #1565c0; }
    #error-modal-inner button {
      margin-top: 18px;
      font-size: 18px;
      padding: 8px 22px;
      background: #2196f3;
      border: none;
      color: white;
      border-radius: 6px;
      cursor: pointer;
      transition: background 0.2s;
      margin-right:10px;
    }
    #error-modal-inner button:last-child {
      margin-right:0;
      background: #ffc107;
      color:#222;
      border: 1.5px solid #ffa000;
    }
    #error-modal-inner button:last-child:hover {
      background: #ffd54f;
      color:#1565c0;
    }
    
    #ranking-modal-inner h2 {
      margin-top: 0;
      font-size: 26px;
      color: #00796b;
    }
    #ranking-list {
      list-style-type: none;
      padding: 0;
      margin: 20px 0;
      text-align: left;
    }
    .ranking-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 10px 15px;
      border-bottom: 1px solid #eee;
      font-size: 16px;
    }
    .ranking-item:last-child {
      border-bottom: none;
    }
    .ranking-item .rank {
      font-weight: bold;
      color: #2196f3;
      min-width: 25px;
      text-align: center;
    }
    .ranking-item .details {
      flex: 1;
      display: flex;
      justify-content: space-between;
      margin-left: 15px;
    }
    .ranking-item .prefill-info {
      font-weight: bold;
      color: #d84315;
    }
    .ranking-item .time-info {
      color: #43a047;
    }
    .ranking-item .error-info {
      color: #f44336;
    }
    #ranking-modal-inner button {
        margin-top: 18px;
        font-size: 18px;
        padding: 8px 22px;
        background: #2196f3;
        border: none;
        color: white;
        border-radius: 6px;
        cursor: pointer;
        transition: background 0.2s;
    }
    #ranking-modal-inner button:hover {
        background: #1565c0;
    }
    
   #pause-mask {
      position: fixed;
      left:0; top:0; right:0; bottom:0;
      background: rgba(0,0,0,1);
      color: #fff;
      font-size: 36px;
      font-weight: bold;
      z-index: 200;
      display: none;
      align-items: center;
      justify-content: center;
      flex-direction: column;
      cursor: pointer;
    }
    #pause-msg {
      text-align: center;
      text-shadow: 0 0 8px #000;
      line-height: 1.4;
    }

/* ğŸ“± æ‰‹æ©Ÿç‰ˆæ’ç‰ˆå„ªåŒ– */
@media (max-width: 600px) {
  body { padding: 4px; }
  h1 {
    font-size: 18px;
    margin: 4px 0;
  }
  
  #status-bar {
    flex-wrap: wrap;
    font-size: 14px;
    gap: 15px;
    margin-bottom: 8px;
  }
  
  #timer {
    font-size: 16px;
    padding: 2px 8px;
  }
  
  #error-count {
    font-size: 14px;
    padding: 2px 8px;
  }
  
  /* æ§åˆ¶æŒ‰éˆ•å€åŸŸé‡æ–°è¨­è¨ˆ */
  #control-bar {
    grid-template-columns: 1fr 1fr;
    grid-template-rows: auto auto;
    gap: 6px;
    max-width: 95vw;
    margin: 0 auto;
  }
  
  /* ç¬¬ä¸€è¡Œï¼šé å¡« + æ–°é¡Œç›® */
  .prefill-group {
    font-size: 18px;
    gap: 6px;
    justify-self: stretch;
    justify-content: center;
  }
  
  #pre-fill-input {
    width: 35px;
    font-size: 12px;
    padding: 3px;
  }
  
  #new-btn {
    font-size: 18px;
    padding: 5px 10px;
    justify-self: stretch;
  }
  
  /* ç¬¬äºŒè¡Œï¼šå››å€‹åŠŸèƒ½æŒ‰éˆ•æ©«æ’ */
  .function-buttons {
    grid-column: 1 / -1;
    display: flex;
    gap: 3px;
    width: 100%;
  }
  
  #note-toggle, #toggle-normal, #pause-btn, #ranking-btn {
    flex: 1;
    font-size: 20px;
    padding: 10px 6px;
    text-align: center;
    height: 40px;
    display: flex;
    align-items: center;
    justify-content: center;
  }
  
  .board {
    grid-template-columns: repeat(9, 1fr);
    width: 95vw;
    margin: 8px auto;
  }
  
  .cell {
    width: 10vw;
    height: 10vw;
    font-size: 4vw;
  }
  
  .number-pad {
    flex-wrap: wrap;
    gap: 6px;
    margin: 10px auto;
    max-width: 95vw;
  }
  
  .num-btn {
    width: 11vw;
    height: 11vw;
    font-size: 5vw;
  }
  
  #ranking-modal-inner {
    width: 90%;
    padding: 20px;
    min-width: unset;
  }
  
  .ranking-item .details {
    flex-direction: column;
    align-items: flex-start;
    margin-left: 10px;
  }
  
  .ranking-item {
    padding: 8px;
  }
  
  .ranking-item .time-info, .ranking-item .error-info {
    font-size: 14px;
    margin-top: 2px;
  }
  
  #pause-mask {
    font-size: 28px;
  }
  
  /* å½ˆçª—æŒ‰éˆ•ä¹Ÿç¸®å° */
  #error-modal-inner, #result-modal-inner {
    padding: 20px;
    font-size: 18px;
    min-width: 200px;
  }
  
  #error-modal-inner button, #result-modal-inner button {
    font-size: 14px;
    padding: 6px 12px;
    margin-top: 12px;
  }
}
  </style>
</head>
<body>
  <h1>æ®ºæ‰‹æ•¸ç¨</h1>
  <div class="top-bar">
    <div id="status-bar">
      <span id="timer">00:00</span>
      <span id="error-count">0/3</span>
    </div>
    <div id="control-bar">
      <div class="prefill-group">
        <label>é å¡«æ ¼æ•¸</label>
        <input id="pre-fill-input" type="number" min="10" max="81" value="25">
      </div>
      <button id="new-btn">ç”¢ç”Ÿæ–°é¡Œç›®</button>
      
      <div class="function-buttons">
        <button id="note-toggle" class="off">ç­†è¨˜</button>
        <button id="toggle-normal">æ™®é€šæ¨¡å¼</button>
        <button id="pause-btn">æš«åœ</button>
        <button id="ranking-btn">è¨ˆåˆ†æ¿</button>
      </div>
    </div>
  </div>
  <div class="board" id="sudoku-board"></div>
  <div class="number-pad" id="number-pad" style="display:none;"></div>
  <div id="finish-mask" style="display:none;">
    <div id="finish-msg">ğŸ‰ å®Œæˆï¼ ğŸ‰</div>
  </div>
  <div id="error-modal" style="display:none;">
    <div id="error-modal-inner">
      <div id="error-modal-title">éŒ¯èª¤æ¬¡æ•¸å·²é”3æ¬¡</div>
      <button id="error-restart-btn">é‡æ–°é–‹å§‹</button>
      <button id="error-continue-btn">ç¹¼çºŒéŠç©</button>
    </div>
  </div>
  <div id="result-modal" style="display:none;">
    <div id="result-modal-inner">
      <div style="font-size:32px; color:#43a047; margin-bottom:10px;">ğŸ‰ æ­å–œå®Œæˆï¼</div>
      <div class="summary" id="result-summary"></div>
      <button id="result-restart-btn">é‡æ–°é–‹å§‹</button>
    </div>
  </div>
  <div id="pause-mask" style="display:none;">
    <div id="pause-msg">â¸ æš«åœä¸­ é»æ“Šç¹¼çºŒ</div>
  </div>
  
  <div id="ranking-modal" style="display:none;">
    <div id="ranking-modal-inner">
      <h2>ğŸ† è¨ˆåˆ†æ¿</h2>
      <ul id="ranking-list">
        </ul>
      <button id="close-ranking-btn">é—œé–‰</button>
    </div>
  </div>
</body>
<script>
const STORAGE_KEY = "killer_sudoku_save_v2";
const TIMER_KEY = "killer_sudoku_timer_v2";
const RANKING_KEY = "killer_sudoku_ranking";
const cageColors = [
  "#ffe5cc", "#ccffcc", "#cce5ff", "#ffd9e6", "#e5ccff", "#ffffcc",
  "#d9e6ff", "#ffcccc", "#ccffe5", "#e6ffd9", "#f5f5dc", "#e0f7fa", "#ffe4e1"
];
let PRE_FILL_NUM = 25;
let answerGrid, cages, preFills, cellValues, preFillMap, cellNotes;
let noteMode = false;
let selectedCell = null;
let errorCount = 0;
let normalMode = false;
let startTime = null, timerInterval = null;
let elapsedSeconds = 0;
let timerPaused = false;
let rankingData = [];

function saveTimer() {
  localStorage.setItem(TIMER_KEY, JSON.stringify({
    startTime: startTime,
    paused: timerPaused,
    elapsedSeconds: elapsedSeconds
  }));
}
function loadTimer() {
  let raw = localStorage.getItem(TIMER_KEY);
  if (!raw) return false;
  try {
    let data = JSON.parse(raw);
    startTime = data.startTime;
    timerPaused = data.paused || false;
    elapsedSeconds = data.elapsedSeconds || 0;
    return true;
  } catch (e) {
    return false;
  }
}
function resetTimer() {
  startTime = Date.now();
  elapsedSeconds = 0;
  timerPaused = false;
  updateTimerDisplay(0);
  saveTimer();
  if (timerInterval) clearInterval(timerInterval);
  timerInterval = setInterval(() => {
    if (!timerPaused) {
      elapsedSeconds = Math.floor((Date.now() - startTime) / 1000);
      updateTimerDisplay(elapsedSeconds);
      saveTimer();
    }
  }, 1000);
}
function resumeTimer() {
  startTime = Date.now() - elapsedSeconds * 1000; // å¾æš«åœæ™‚çš„è¨ˆæ™‚é‡æ–°é–‹å§‹
  timerPaused = false;
  saveTimer();
  if (timerInterval) clearInterval(timerInterval);
  timerInterval = setInterval(() => {
    if (!timerPaused) {
      elapsedSeconds = Math.floor((Date.now() - startTime) / 1000);
      updateTimerDisplay(elapsedSeconds);
      saveTimer();
    }
  }, 1000);
}
function startTimer() {
  if (!startTime) {
    resetTimer();
  } else {
    resumeTimer();
    updateTimerDisplay(elapsedSeconds);
  }
}
function stopTimer() {
  timerPaused = true;
  saveTimer();
  if (timerInterval) {
    clearInterval(timerInterval);
    timerInterval = null;
  }
}
function updateTimerDisplay(sec) {
  let mins = Math.floor(sec / 60);
  let s = sec % 60;
  document.getElementById("timer").textContent = (mins<10?"0":"")+mins+":"+(s<10?"0":"")+s;
}
function getElapsedSeconds() {
  if (startTime && !timerPaused) return Math.floor((Date.now() - startTime) / 1000);
  return elapsedSeconds;
}

function is9x9Array(arr) {
  return Array.isArray(arr) && arr.length === 9 && arr.every(row => Array.isArray(row) && row.length === 9);
}
function safeLoadFromStorage() {
  const raw = localStorage.getItem(STORAGE_KEY);
  if(!raw) return false;
  try {
    const data = JSON.parse(raw);
    if (!is9x9Array(data.cellValues) ||
        !is9x9Array(data.cellNotes) ||
        !is9x9Array(data.preFillMap) ||
        !is9x9Array(data.answerGrid) ||
        !Array.isArray(data.cages) ||
        !Array.isArray(data.preFills)) return false;
    answerGrid = data.answerGrid;
    cages = data.cages;
    preFills = data.preFills;
    cellValues = data.cellValues;
    preFillMap = data.preFillMap;
    cellNotes = data.cellNotes;
    PRE_FILL_NUM = data.PRE_FILL_NUM || 25;
    errorCount = data.errorCount || 0;
    selectedCell = null;
    return true;
  } catch(e) {
    return false;
  }
}
function saveToStorage() {
  const data = {
    answerGrid, cages, preFills, cellValues, preFillMap, cellNotes,
    PRE_FILL_NUM, errorCount,
    gameCompleted: isFinished(cellValues, answerGrid, preFillMap), // â† åŠ é€™è¡Œ
    finalTime: isFinished(cellValues, answerGrid, preFillMap) ? getElapsedSeconds() : null // â† åŠ é€™è¡Œ
  };
  localStorage.setItem(STORAGE_KEY, JSON.stringify(data));
}
// æª¢æŸ¥æ•¸ç¨æ˜¯å¦æœ‰å”¯ä¸€è§£
function hasUniqueSolution(grid) {
  let solutionCount = 0;
  const testGrid = grid.map(row => [...row]);
  
  function solve(r = 0, c = 0) {
    if (r === 9) {
      solutionCount++;
      return solutionCount > 1; // æ‰¾åˆ°è¶…é1å€‹è§£å°±åœæ­¢
    }
    if (c === 9) return solve(r + 1, 0);
    if (testGrid[r][c] !== 0) return solve(r, c + 1);
    
    for (let num = 1; num <= 9; num++) {
      if (isValidMove(testGrid, r, c, num)) {
        testGrid[r][c] = num;
        if (solve(r, c + 1)) return true;
        testGrid[r][c] = 0;
      }
    }
    return false;
  }
  
  solve();
  return solutionCount === 1;
}

function isValidMove(grid, row, col, num) {
  // æª¢æŸ¥è¡Œ
  for (let c = 0; c < 9; c++) {
    if (grid[row][c] === num) return false;
  }
  // æª¢æŸ¥åˆ—  
  for (let r = 0; r < 9; r++) {
    if (grid[r][col] === num) return false;
  }
  // æª¢æŸ¥3x3å€åŸŸ
  const boxRow = Math.floor(row / 3) * 3;
  const boxCol = Math.floor(col / 3) * 3;
  for (let r = 0; r < 3; r++) {
    for (let c = 0; c < 3; c++) {
      if (grid[boxRow + r][boxCol + c] === num) return false;
    }
  }
  return true;
}

// ç›¤é¢ç”Ÿæˆ
function generateSudoku() {
  const grid = Array.from({length:9},()=>Array(9).fill(0));
  const nums = [1,2,3,4,5,6,7,8,9];
  function shuffle(arr) {
    for(let i=arr.length-1;i>0;i--){
      const j=Math.floor(Math.random()*(i+1));
      [arr[i],arr[j]]=[arr[j],arr[i]];
    }
  }
  function fill(r=0,c=0) {
    if(r==9) return true;
    if(c==9) return fill(r+1,0);
    shuffle(nums);
    for(const v of nums) {
      if(valid(r,c,v)) {
        grid[r][c]=v;
        if(fill(r,c+1)) return true;
        grid[r][c]=0;
      }
    }
    return false;
  }
  function valid(r,c,v){
    for(let i=0;i<9;i++)
      if(grid[r][i]==v||grid[i][c]==v) return false;
    const br=Math.floor(r/3)*3,bc=Math.floor(c/3)*3;
    for(let i=0;i<3;i++) for(let j=0;j<3;j++)
      if(grid[br+i][bc+j]==v) return false;
    return true;
  }
  fill();
  return grid;
}
function generateCages(grid) {
  const marked = Array.from({length:9},()=>Array(9).fill(false));
  const cages = [];
  const directions = [[0,1],[1,0],[0,-1],[-1,0]];
  while(true){
    let found=false;
    for(let r=0;r<9&&!found;r++)
      for(let c=0;c<9&&!found;c++)
        if(!marked[r][c]) {
          found=true;
          let size = Math.floor(Math.random()*3)+2;
          const cageCells=[[r,c]];
          marked[r][c]=true;
          for(let k=1;k<size;k++){
            let candidates=[];
            for(const [cr,cc] of cageCells){
              for(const [dr,dc] of directions){
                let nr=cr+dr,nc=cc+dc;
                if(nr>=0&&nr<9&&nc>=0&&nc<9&&!marked[nr][nc]){
                  candidates.push([nr,nc]);
                }
              }
            }
            if(candidates.length){
              const [nr,nc]=candidates[Math.floor(Math.random()*candidates.length)];
              cageCells.push([nr,nc]);
              marked[nr][nc]=true;
            }
          }
          let sum = cageCells.reduce((a,[r,c])=>a+grid[r][c],0);
          cages.push({sum:sum,cells:cageCells});
        }
    if(!found) break;
  }
  return cages;
}
function assignCageColors(cages) {
  function getCageIdMap(cages) {
    const map = Array.from({length:9},()=>Array(9).fill(-1));
    cages.forEach((cage, idx) => cage.cells.forEach(([r,c]) => map[r][c]=idx));
    return map;
  }
  const map = getCageIdMap(cages);
  const cageAdj = cages.map(()=>new Set());
  cages.forEach((cage, idx) => {
    cage.cells.forEach(([r,c]) => {
      [[0,1],[1,0],[0,-1],[-1,0]].forEach(([dr,dc])=>{
        let nr=r+dr,nc=c+dc;
        if(nr>=0&&nr<9&&nc>=0&&nc<9){
          let nId = map[nr][nc];
          if(nId!==idx && nId!==-1) cageAdj[idx].add(nId);
        }
      });
    });
  });
  const cageColorIdx = [];
  for(let i=0;i<cages.length;i++){
    let used = new Set();
    for(const adj of cageAdj[i]) {
      if(typeof cageColorIdx[adj]==="number") used.add(cageColorIdx[adj]);
    }
    let pick = 0;
    while(used.has(pick)) pick++;
    cageColorIdx[i]=pick % cageColors.length;
  }
  cages.forEach((cage, idx) => cage.color = cageColors[cageColorIdx[idx]]);
  return cages;
}
function getPreFilled(grid, num) {
  const all = [];
  for(let r=0;r<9;r++) for(let c=0;c<9;c++) all.push([r,c]);
  
  let attempts = 0;
  while(attempts < 100) { // æœ€å¤šå˜—è©¦100æ¬¡
    attempts++;
    
    // éš¨æ©Ÿæ‰“äº‚æ‰€æœ‰ä½ç½®
    for(let i=all.length-1;i>0;i--){
      const j=Math.floor(Math.random()*(i+1));
      [all[i],all[j]]=[all[j],all[i]];
    }
    
    // å‰µå»ºæ¸¬è©¦ç”¨çš„é¡Œç›®ç¶²æ ¼
    const testGrid = grid.map(row => [...row]);
    const selectedPositions = all.slice(0, num);
    
    // ç§»é™¤éé å¡«æ ¼å­çš„æ•¸å­—
    for(let r=0;r<9;r++) {
      for(let c=0;c<9;c++) {
        if(!selectedPositions.some(([rr,cc]) => rr===r && cc===c)) {
          testGrid[r][c] = 0;
        }
      }
    }
    
    // æª¢æŸ¥æ˜¯å¦æœ‰å”¯ä¸€è§£
    if(hasUniqueSolution(testGrid)) {
      return selectedPositions.map(([r,c])=>({r,c,value:grid[r][c]}));
    }
  }
  
  // å¦‚æœ100æ¬¡éƒ½å¤±æ•—ï¼Œä½¿ç”¨ä¿å®ˆç­–ç•¥ï¼ˆæ›´å¤šé å¡«æ ¼ï¼‰
  console.log("ä½¿ç”¨ä¿å®ˆé å¡«ç­–ç•¥");
  const conservativeNum = Math.min(81, num + 10);
  for(let i=all.length-1;i>0;i--){
    const j=Math.floor(Math.random()*(i+1));
    [all[i],all[j]]=[all[j],all[i]];
  }
  return all.slice(0, conservativeNum).map(([r,c])=>({r,c,value:grid[r][c]}));
}
function getCageId(r,c) {
  if (normalMode) return -1;
  for(let i=0;i<cages.length;i++)
    if(cages[i].cells.some(([rr,cc])=>rr===r&&cc===c)) return i;
  return -1;
}
function getCageInnerBorders(r, c, cage) {
  if (normalMode) return {};
  let borders = {};
  if(!cage.cells.some(([rr,cc])=>rr===r-1&&cc===c)) borders.top=true;
  if(!cage.cells.some(([rr,cc])=>rr===r+1&&cc===c)) borders.bottom=true;
  if(!cage.cells.some(([rr,cc])=>rr===r&&cc===c-1)) borders.left=true;
  if(!cage.cells.some(([rr,cc])=>rr===r&&cc===c+1)) borders.right=true;
  return borders;
}
function getBoxBorders(r, c) {
  let borders = {};
  if(r%3===0) borders.top=true;
  if(r%3===2) borders.bottom=true;
  if(c%3===0) borders.left=true;
  if(c%3===2) borders.right=true;
  return borders;
}
function getErrorCells(cellValues, answerGrid, preFillMap) {
  const errors = Array.from({length:9},()=>Array(9).fill(false));
  for(let r=0;r<9;r++) for(let c=0;c<9;c++)
    if(cellValues[r][c] && Number(cellValues[r][c]) !== answerGrid[r][c] && !preFillMap[r][c])
      errors[r][c]=true;
  return errors;
}
function isFinished(cellValues, answerGrid, preFillMap) {
  for(let r=0;r<9;r++) for(let c=0;c<9;c++) {
    if(!cellValues[r][c]) return false;
    if(!preFillMap[r][c] && Number(cellValues[r][c]) !== answerGrid[r][c]) return false;
  }
  return true;
}
function showFinishDialog() {
  stopTimer();
  const finalTime = getElapsedSeconds(); // â† å…ˆä¿å­˜æœ€çµ‚æ™‚é–“
  document.getElementById("result-modal").style.display = "flex";
  document.getElementById("result-summary").innerHTML =
    `<p>é å¡«æ ¼æ•¸ï¼š<b>${PRE_FILL_NUM}</b></p>
     <p>ç”¨æ™‚ï¼š<b>${formatSeconds(finalTime)}</b></p>
     <p>ç­”éŒ¯æ¬¡æ•¸ï¼š<b>${errorCount}</b></p>`;
  addRankingEntry(PRE_FILL_NUM, finalTime, errorCount); // â† ç”¨ finalTime
}
function formatSeconds(sec) {
  let mins = Math.floor(sec/60);
  let s = sec%60;
  return (mins<10?"0":"")+mins+":"+(s<10?"0":"")+s;
}
function hideFinishDialog() {
  document.getElementById("result-modal").style.display = "none";
}
function showErrorModal() {
  stopTimer();
  document.getElementById("error-modal").style.display = "flex";
  document.getElementById("error-modal-title").textContent = "éŒ¯èª¤æ¬¡æ•¸å·²é”3æ¬¡";
}
function hideErrorModal() {
  document.getElementById("error-modal").style.display = "none";
}
function getHighlightMap() {
  const map = Array.from({length:9},()=>Array(9).fill(false));
  if(selectedCell) {
    const [sr,sc] = selectedCell;
    const val = cellValues[sr][sc];
    if(val) {
      for(let i=0;i<9;i++) map[sr][i]=true;
      for(let i=0;i<9;i++) map[i][sc]=true;
      const br=Math.floor(sr/3)*3, bc=Math.floor(sc/3)*3;
      for(let r=br;r<br+3;r++) for(let c=bc;c<bc+3;c++) map[r][c]=true;
      for(let r=0;r<9;r++) for(let c=0;c<9;c++)
        if(cellValues[r][c]==val) map[r][c]=true;
    } else {
      map[sr][sc]=true;
    }
  }
  return map;
}
function getFilledNumberCounts() {
  const counts = Array(10).fill(0);
  for(let r=0;r<9;r++) for(let c=0;c<9;c++) {
    const v = cellValues[r][c];
    if(v) counts[Number(v)]++;
  }
  return counts;
}
function newPuzzle(preFillNum) {
  PRE_FILL_NUM = preFillNum;
  answerGrid = generateSudoku();
  cages = assignCageColors(generateCages(answerGrid));
  preFills = getPreFilled(answerGrid, PRE_FILL_NUM);
  cellValues = Array.from({length:9},()=>Array(9).fill(''));
  preFillMap = Array.from({length:9},()=>Array(9).fill(false));
  cellNotes = Array.from({length:9},()=>Array.from({length:9},()=>[]));
  errorCount = 0;
  for(const {r,c,value} of preFills) {
    cellValues[r][c]=value;
    preFillMap[r][c]=true;
  }
  selectedCell = null;
  saveToStorage();
  renderBoard();
  document.getElementById("finish-mask").style.display = "none";
  hideErrorModal();
  hideFinishDialog();
  resetTimer();
  updateErrorDisplay();
}
const board = document.getElementById('sudoku-board');
function renderBoard() {
  const errorCells = getErrorCells(cellValues, answerGrid, preFillMap);
  const highlightMap = getHighlightMap();
  board.innerHTML = '';
  for(let r=0; r<9; r++) {
    for(let c=0; c<9; c++) {
      const cell = document.createElement('div');
      cell.className = 'cell';
      const boxBorders = getBoxBorders(r,c);
      if(boxBorders.top) cell.style.borderTop = '1.5px solid #222';
      if(boxBorders.bottom) cell.style.borderBottom = '1.5px solid #222';
      if(boxBorders.left) cell.style.borderLeft = '1.5px solid #222';
      if(boxBorders.right) cell.style.borderRight = '1.5px solid #222';
      let cageId = getCageId(r, c);
      if(cageId!==-1 && !normalMode) cell.style.background = cages[cageId].color;
      if(selectedCell && selectedCell[0]===r && selectedCell[1]===c)
        cell.classList.add('selected');
      if(highlightMap[r][c]) cell.classList.add('hilight');
      if(!normalMode) {
        cages.forEach((cage) => {
          const [cr,cc] = cage.cells[0];
          if(cr===r && cc===c) {
            const label = document.createElement('div');
            label.className = 'sum-label';
            label.innerText = cage.sum;
            cell.appendChild(label);
          }
        });
      }
      if(cellNotes[r][c] && cellNotes[r][c].length>0 && !cellValues[r][c]) {
        const notes = document.createElement('div');
        notes.className = 'notes';
        if(noteMode) notes.style.background = '#fffbe7';
        for(let i=1;i<=9;i++) {
          const span = document.createElement('span');
          if(cellNotes[r][c].includes(i)) span.textContent = i;
          notes.appendChild(span);
        }
        cell.appendChild(notes);
      }
      let numHtml = '';
      if(preFillMap[r][c]) {
        numHtml = `<span class="cell-value pre-fill">${cellValues[r][c]}</span>`;
      } else if(cellValues[r][c]) {
        numHtml = `<span class="cell-value${errorCells[r][c] ? ' error' : ''}">${cellValues[r][c]}</span>`;
      }
      cell.innerHTML += numHtml;
      cell.addEventListener('click', () => {
        selectedCell = [r,c];
        renderBoard();
        showNumberPad();
      });
      board.appendChild(cell);
    }
  }
  saveToStorage();
  updateErrorDisplay();
  // ç­†è¨˜æ¨¡å¼æç¤ºæŒ‰éˆ•æ–‡å­—
  const noteBtn = document.getElementById("note-toggle");
  if(noteMode) {
    noteBtn.textContent = "ç­†è¨˜ ON";
    noteBtn.classList.remove("off");
    noteBtn.classList.add("on");
  } else {
    noteBtn.textContent = "ç­†è¨˜ OFF";
    noteBtn.classList.remove("on");
    noteBtn.classList.add("off");
  }
  if(isFinished(cellValues, answerGrid, preFillMap)) {
    showFinishDialog();
  }
}
function showNumberPad() {
  const pad = document.getElementById('number-pad');
  pad.innerHTML = '';
  pad.style.display = selectedCell ? 'flex' : 'none';
  const counts = getFilledNumberCounts();
  for(let i=1;i<=9;i++) {
    const btn = document.createElement('button');
    btn.className = 'num-btn';
    btn.textContent = i;
    if(counts[i]>=9) btn.classList.add('inactive');
    btn.disabled = counts[i]>=9;
    btn.addEventListener('click', () => {
      if(selectedCell && counts[i]<9) {
        const [r,c] = selectedCell;
        if(noteMode) {
          if(!cellNotes[r][c]) cellNotes[r][c]=[];
          if(cellNotes[r][c].includes(i)) {
            cellNotes[r][c]=cellNotes[r][c].filter(x=>x!==i);
          } else {
            cellNotes[r][c].push(i);
            cellNotes[r][c].sort();
          }
          saveToStorage();
          renderBoard();
        } else {
          if(preFillMap[r][c]) return;
          if(Number(i)!==answerGrid[r][c]) {
            errorCount++;
            saveToStorage();
            updateErrorDisplay();
            if(errorCount>=3) {
              showErrorModal();
              return;
            }
          }
          cellValues[r][c] = i;
          cellNotes[r][c] = [];
          selectedCell = null;
          saveToStorage();
          renderBoard();
        }
      }
    });
    pad.appendChild(btn);
  }
  const delBtn = document.createElement('button');
  delBtn.className = 'num-btn del';
  delBtn.textContent = 'X';
  delBtn.addEventListener('click', () => {
    if(selectedCell) {
      const [r,c] = selectedCell;
      if(noteMode) {
        cellNotes[r][c] = [];
        saveToStorage();
        renderBoard();
      } else {
        if(preFillMap[r][c]) return;
        cellValues[r][c] = '';
        saveToStorage();
        selectedCell = null;
        renderBoard();
      }
    }
  });
  pad.appendChild(delBtn);
}
function updateErrorDisplay() {
  document.getElementById("error-count").textContent = `${errorCount}/3`;
}
// æ’ååŠŸèƒ½
function loadRanking() {
  const raw = localStorage.getItem(RANKING_KEY);
  try {
    rankingData = raw ? JSON.parse(raw) : [];
  } catch (e) {
    rankingData = [];
  }
}
function saveRanking() {
  localStorage.setItem(RANKING_KEY, JSON.stringify(rankingData));
}
function addRankingEntry(prefill, time, errors) {
    
    // æ·»åŠ æ™‚é–“æˆ³é¿å…é‡è¤‡
    const timestamp = Date.now();
    rankingData.push({ prefill, time, errors, timestamp });
    sortRanking();
    
    // ä¿ç•™å‰10å
    rankingData = rankingData.slice(0, 10);
    saveRanking();
    console.log(`æ–°å¢è¨˜éŒ„: é å¡«${prefill}, éŒ¯èª¤${errors}, æ™‚é–“${time}s, ç¸½è¨˜éŒ„æ•¸: ${rankingData.length}`);
}
function sortRanking() {
    rankingData.sort((a, b) => {
        // 1. é å¡«æ ¼æ•¸: æ•¸å­—è¶Šå°‘è¶Šå¥½ (å‡åº)
        if (a.prefill !== b.prefill) {
            return a.prefill - b.prefill;
        }
        // 2. éŒ¯èª¤æ¬¡æ•¸: éŒ¯èª¤è¶Šå°‘è¶Šå¥½ (å‡åº)  
        if (a.errors !== b.errors) {
            return a.errors - b.errors;
        }
        // 3. æ™‚é–“: æ™‚é–“è¶ŠçŸ­è¶Šå¥½ (å‡åº)
        return a.time - b.time;
    });
}
function showRankingModal() {
  const modal = document.getElementById("ranking-modal");
  const list = document.getElementById("ranking-list");
  
  // å…ˆæ¸…ç©ºåˆ—è¡¨
  list.innerHTML = "";
  
  console.log(`é¡¯ç¤ºæ’åï¼Œå…±æœ‰ ${rankingData.length} ç­†è¨˜éŒ„`);
  
  if (rankingData.length === 0) {
    const noData = document.createElement('li');
    noData.textContent = "ç›®å‰æ²’æœ‰æ’åç´€éŒ„";
    noData.style.textAlign = "center";
    noData.style.fontSize = "16px";
    noData.style.color = "#888";
    noData.style.padding = "20px";
    list.appendChild(noData);
  } else {
    rankingData.forEach((entry, index) => {
      const li = document.createElement('li');
      li.className = 'ranking-item';
      
      // æ ¹æ“šæ’åçµ¦ä¸åŒçš„çç« 
      let medal = "";
      if (index === 0) medal = "ğŸ¥‡";
      else if (index === 1) medal = "ğŸ¥ˆ"; 
      else if (index === 2) medal = "ğŸ¥‰";
      else medal = `#${index + 1}`;
      
      li.innerHTML = `
        <span class="rank">${medal}</span>
        <div class="details">
          <span class="prefill-info">é å¡«ï¼š${entry.prefill}</span>
          <span class="error-info">éŒ¯èª¤ï¼š${entry.errors}</span>
          <span class="time-info">ç”¨æ™‚ï¼š${formatSeconds(entry.time)}</span>
        </div>
      `;
      list.appendChild(li);
    });
  }
  modal.style.display = "flex";
}
function hideRankingModal() {
  document.getElementById("ranking-modal").style.display = "none";
}

// äº‹ä»¶
document.getElementById("new-btn").onclick = () => {
  const n = parseInt(document.getElementById("pre-fill-input").value,10);
  let num = Math.max(10, Math.min(81, isNaN(n)?25:n));
  newPuzzle(num);
};
document.getElementById("note-toggle").onclick = () => {
  noteMode = !noteMode;
  renderBoard();
};
document.getElementById("result-restart-btn").onclick = () => {
  hideFinishDialog();
  const n = parseInt(document.getElementById("pre-fill-input").value,10);
  let num = Math.max(10, Math.min(81, isNaN(n)?25:n));
  newPuzzle(num);
};
document.getElementById("error-restart-btn").onclick = () => {
  hideErrorModal();
  const n = parseInt(document.getElementById("pre-fill-input").value,10);
  let num = Math.max(10, Math.min(81, isNaN(n)?25:n));
  newPuzzle(num);
};
document.getElementById("error-continue-btn").onclick = () => {
  hideErrorModal();
  resumeTimer();
};
document.getElementById("toggle-normal").onclick = () => {
  normalMode = !normalMode;
  document.getElementById("toggle-normal").classList.toggle("active", normalMode);
  renderBoard();
};
document.getElementById("ranking-btn").onclick = showRankingModal;
document.getElementById("close-ranking-btn").onclick = hideRankingModal;

// æ¢å¾©æš«åœåŠŸèƒ½çš„åŸå§‹é‚è¼¯
document.getElementById("pause-btn").onclick = () => {
  const btn = document.getElementById("pause-btn");
  const mask = document.getElementById("pause-mask");
  if (timerPaused) {
    // ç¹¼çºŒ
    resumeTimer();
    btn.textContent = "æš«åœ";
    btn.classList.remove("paused");
    mask.style.display = "none";
  } else {
    // æš«åœ
    stopTimer();
    btn.textContent = "ç¹¼çºŒ";
    btn.classList.add("paused");
    mask.style.display = "flex";
  }
};
document.getElementById("pause-mask").onclick = () => {
  resumeTimer();
  document.getElementById("pause-btn").textContent = "æš«åœ";
  document.getElementById("pause-btn").classList.remove("paused");
  document.getElementById("pause-mask").style.display = "none";
};

// é¦–æ¬¡è¼‰å…¥æˆ–F5æ™‚ï¼Œé‚„åŸtimer
if(!safeLoadFromStorage()) {
  newPuzzle(PRE_FILL_NUM);
} else {
  renderBoard();
  if (!loadTimer()) {
    resetTimer();
  } else {
    resumeTimer();
    updateTimerDisplay(elapsedSeconds);
  }
}
loadRanking();
window.addEventListener('beforeunload', function() {
  saveTimer();
});
</script>
</html>
