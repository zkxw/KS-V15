<!DOCTYPE html>
<html lang="zh-Hant">
<head>
  <meta charset="UTF-8">
  <title>æ®ºæ‰‹æ•¸ç¨ï¼ˆå®Œæˆå‹•ç•«ï¼‹å¯èª¿é å¡«æ ¼ï¼‰</title>
  <style>
    body { font-family: sans-serif; }
    .board {
      display: grid;
      grid-template-columns: repeat(9, 40px);
      gap: 0px;
      width: fit-content;
      margin: 30px auto 10px;
      border: 4px solid #222;
    }
    .cell {
      position: relative;
      width: 40px;
      height: 40px;
      border: 1px solid #aaa;
      text-align: center;
      font-size: 20px;
      background: #fff;
      cursor: pointer;
      box-sizing: border-box;
      overflow: hidden;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    .cell.selected { border: 2px solid #2196f3; background: #e3f2fd; }
    .sum-label {
      position: absolute;
      top: 2px; left: 2px;
      font-size: 10px; color: #333;
      pointer-events:none;
      z-index: 3;
      background: inherit;
      padding: 1px 2px;
      border-radius: 5px;
    }
    .pre-fill { color: #00796b; font-weight: bold; z-index: 4; }
    .number-pad { display: flex; justify-content: center; gap: 8px; margin-top: 14px; }
    .num-btn { width: 34px; height: 34px; font-size: 20px; border: 1px solid #2196f3; border-radius: 6px; background: #f5f5f5; cursor: pointer; }
    .num-btn:hover { background: #2196f3; color: white; }
    .num-btn.del { border: 1px solid #f44336; color: #f44336; }
    .num-btn.del:hover { background: #f44336; color: white; }
    .cage-border-inner {
      position: absolute;
      pointer-events:none;
      z-index: 2;
      box-sizing: border-box;
      left: 5px; top: 5px; right: 5px; bottom: 5px;
      border: none;
    }
    .cell-value {
      width: 100%;
      height: 100%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 20px;
      z-index: 4;
      position: relative;
    }
    .cell-value.error {
      color: #f44336;
      font-weight: bold;
    }
    #control-bar {
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 10px;
      margin-top: 16px;
      margin-bottom: 0;
    }
    #pre-fill-input {
      width: 50px;
      font-size: 16px;
      text-align: center;
      padding: 2px 6px;
      border-radius: 4px;
      border: 1px solid #aaa;
    }
    button#new-btn {
      font-size: 18px;
      padding: 6px 16px;
      background: #2196f3;
      border: none;
      color: white;
      border-radius: 6px;
      cursor: pointer;
      transition: background 0.2s;
    }
    button#new-btn:hover { background: #1565c0; }
    /* å®Œæˆå‹•ç•« */
    #finish-mask {
      position: fixed;
      left:0; top:0; right:0; bottom:0;
      background: rgba(255,255,255,0.8);
      z-index: 99;
      display: flex;
      align-items: center;
      justify-content: center;
      animation: fadeIn 0.4s;
    }
    #finish-msg {
      font-size: 40px;
      font-weight: bold;
      color: #43a047;
      text-align: center;
      background: linear-gradient(90deg,#fa709a,#fee140,#43e97b 80%);
      background-clip: text;
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      animation: rainbow 1.2s linear infinite;
    }
    @keyframes fadeIn {
      from { opacity:0; }
      to { opacity:1; }
    }
    @keyframes rainbow {
      0%{ filter:hue-rotate(0deg); }
      100%{ filter:hue-rotate(360deg);}
    }
  </style>
</head>
<body>
  <h1>æ®ºæ‰‹æ•¸ç¨ï¼ˆå®Œæˆå‹•ç•«ï¼‹å¯èª¿é å¡«æ ¼ï¼‰</h1>
  <div id="control-bar">
    <label>é å¡«æ ¼æ•¸ <input id="pre-fill-input" type="number" min="10" max="81" value="25"></label>
    <button id="new-btn">ç”¢ç”Ÿæ–°é¡Œç›®</button>
  </div>
  <div class="board" id="sudoku-board"></div>
  <div class="number-pad" id="number-pad" style="display:none;"></div>
  <div id="finish-mask" style="display:none;">
    <div id="finish-msg">ğŸ‰ å®Œæˆï¼ ğŸ‰</div>
  </div>
</body>
<script>
  // è‰²ç›¤ (å¯å¢æ¸›)
  const cageColors = [
    "#ffe5cc", "#ccffcc", "#cce5ff", "#ffd9e6", "#e5ccff", "#ffffcc",
    "#d9e6ff", "#ffcccc", "#ccffe5", "#e6ffd9", "#f5f5dc", "#e0f7fa", "#ffe4e1"
  ];

  let PRE_FILL_NUM = 25;
  let answerGrid, cages, preFills, cellValues, preFillMap;

  function generateSudoku() {
    const grid = Array.from({length:9},()=>Array(9).fill(0));
    const nums = [1,2,3,4,5,6,7,8,9];
    function shuffle(arr) {
      for(let i=arr.length-1;i>0;i--){
        const j=Math.floor(Math.random()*(i+1));
        [arr[i],arr[j]]=[arr[j],arr[i]];
      }
    }
    function fill(r=0,c=0) {
      if(r==9) return true;
      if(c==9) return fill(r+1,0);
      shuffle(nums);
      for(const v of nums) {
        if(valid(r,c,v)) {
          grid[r][c]=v;
          if(fill(r,c+1)) return true;
          grid[r][c]=0;
        }
      }
      return false;
    }
    function valid(r,c,v){
      for(let i=0;i<9;i++)
        if(grid[r][i]==v||grid[i][c]==v) return false;
      const br=Math.floor(r/3)*3,bc=Math.floor(c/3)*3;
      for(let i=0;i<3;i++) for(let j=0;j<3;j++)
        if(grid[br+i][bc+j]==v) return false;
      return true;
    }
    fill();
    return grid;
  }

  function generateCages(grid) {
    const marked = Array.from({length:9},()=>Array(9).fill(false));
    const cages = [];
    const directions = [[0,1],[1,0],[0,-1],[-1,0]];
    while(true){
      let found=false;
      for(let r=0;r<9&&!found;r++)
        for(let c=0;c<9&&!found;c++)
          if(!marked[r][c]) {
            found=true;
            let size = Math.floor(Math.random()*3)+2;
            const cageCells=[[r,c]];
            marked[r][c]=true;
            for(let k=1;k<size;k++){
              let candidates=[];
              for(const [cr,cc] of cageCells){
                for(const [dr,dc] of directions){
                  let nr=cr+dr,nc=cc+dc;
                  if(nr>=0&&nr<9&&nc>=0&&nc<9&&!marked[nr][nc]){
                    candidates.push([nr,nc]);
                  }
                }
              }
              if(candidates.length){
                const [nr,nc]=candidates[Math.floor(Math.random()*candidates.length)];
                cageCells.push([nr,nc]);
                marked[nr][nc]=true;
              }
            }
            let sum = cageCells.reduce((a,[r,c])=>a+grid[r][c],0);
            cages.push({sum:sum,cells:cageCells});
          }
      if(!found) break;
    }
    return cages;
  }

  function assignCageColors(cages) {
    function getCageIdMap(cages) {
      const map = Array.from({length:9},()=>Array(9).fill(-1));
      cages.forEach((cage, idx) => cage.cells.forEach(([r,c]) => map[r][c]=idx));
      return map;
    }
    const map = getCageIdMap(cages);
    const cageAdj = cages.map(()=>new Set());
    cages.forEach((cage, idx) => {
      cage.cells.forEach(([r,c]) => {
        [[0,1],[1,0],[0,-1],[-1,0]].forEach(([dr,dc])=>{
          let nr=r+dr,nc=c+dc;
          if(nr>=0&&nr<9&&nc>=0&&nc<9){
            let nId = map[nr][nc];
            if(nId!==idx && nId!==-1) cageAdj[idx].add(nId);
          }
        });
      });
    });
    const cageColorIdx = [];
    for(let i=0;i<cages.length;i++){
      let used = new Set();
      for(const adj of cageAdj[i]) {
        if(typeof cageColorIdx[adj]==="number") used.add(cageColorIdx[adj]);
      }
      let pick = 0;
      while(used.has(pick)) pick++;
      cageColorIdx[i]=pick % cageColors.length;
    }
    cages.forEach((cage, idx) => cage.color = cageColors[cageColorIdx[idx]]);
    return cages;
  }

  function getPreFilled(grid, num) {
    const all = [];
    for(let r=0;r<9;r++) for(let c=0;c<9;c++) all.push([r,c]);
    for(let i=all.length-1;i>0;i--){
      const j=Math.floor(Math.random()*(i+1));
      [all[i],all[j]]=[all[j],all[i]];
    }
    return all.slice(0,num).map(([r,c])=>({r,c,value:grid[r][c]}));
  }

  function getCageId(r,c) {
    for(let i=0;i<cages.length;i++)
      if(cages[i].cells.some(([rr,cc])=>rr===r&&cc===c)) return i;
    return -1;
  }

  function getCageInnerBorders(r, c, cage) {
    let borders = {};
    if(!cage.cells.some(([rr,cc])=>rr===r-1&&cc===c)) borders.top=true;
    if(!cage.cells.some(([rr,cc])=>rr===r+1&&cc===c)) borders.bottom=true;
    if(!cage.cells.some(([rr,cc])=>rr===r&&cc===c-1)) borders.left=true;
    if(!cage.cells.some(([rr,cc])=>rr===r&&cc===c+1)) borders.right=true;
    return borders;
  }

  function getBoxBorders(r, c) {
    let borders = {};
    if(r%3===0) borders.top=true;
    if(r%3===2) borders.bottom=true;
    if(c%3===0) borders.left=true;
    if(c%3===2) borders.right=true;
    return borders;
  }

  function getErrorCells(cellValues, answerGrid, preFillMap) {
    const errors = Array.from({length:9},()=>Array(9).fill(false));
    for(let r=0;r<9;r++) for(let c=0;c<9;c++)
      if(cellValues[r][c] && Number(cellValues[r][c]) !== answerGrid[r][c] && !preFillMap[r][c])
        errors[r][c]=true;
    return errors;
  }

  // åˆ¤æ–·æ˜¯å¦å…¨éƒ¨å¡«å®Œä¸”ç„¡éŒ¯èª¤
  function isFinished(cellValues, answerGrid, preFillMap) {
    for(let r=0;r<9;r++) for(let c=0;c<9;c++) {
      if(!cellValues[r][c]) return false;
      if(!preFillMap[r][c] && Number(cellValues[r][c]) !== answerGrid[r][c]) return false;
    }
    return true;
  }

  // é¡¯ç¤ºå®Œæˆå‹•ç•«
  function showFinishAnimation() {
    document.getElementById("finish-mask").style.display = "flex";
    setTimeout(()=> {
      document.getElementById("finish-mask").style.display = "none";
    }, 1800);
  }

  // åˆå§‹åŒ–ç›¤é¢
  function newPuzzle(preFillNum) {
    PRE_FILL_NUM = preFillNum;
    answerGrid = generateSudoku();
    cages = assignCageColors(generateCages(answerGrid));
    preFills = getPreFilled(answerGrid, PRE_FILL_NUM);
    cellValues = Array.from({length:9},()=>Array(9).fill(''));
    preFillMap = Array.from({length:9},()=>Array(9).fill(false));
    for(const {r,c,value} of preFills) {
      cellValues[r][c]=value;
      preFillMap[r][c]=true;
    }
    selectedCell = null;
    renderBoard();
    document.getElementById("finish-mask").style.display = "none";
  }

  const board = document.getElementById('sudoku-board');
  let selectedCell = null;

  function renderBoard() {
    const errorCells = getErrorCells(cellValues, answerGrid, preFillMap);
    board.innerHTML = '';
    for(let r=0; r<9; r++) {
      for(let c=0; c<9; c++) {
        const cell = document.createElement('div');
        cell.className = 'cell';
        // ä¹å®®æ ¼ç²—æ¡†
        const boxBorders = getBoxBorders(r,c);
        if(boxBorders.top) cell.style.borderTop = '1.5px solid #222';
        if(boxBorders.bottom) cell.style.borderBottom = '1.5px solid #222';
        if(boxBorders.left) cell.style.borderLeft = '1.5px solid #222';
        if(boxBorders.right) cell.style.borderRight = '1.5px solid #222';

        // ç± å­åº•è‰²
        let cageId = getCageId(r, c);
        if(cageId!==-1) cell.style.background = cages[cageId].color;

        if(selectedCell && selectedCell[0]===r && selectedCell[1]===c)
          cell.classList.add('selected');

        // ç± å­è™›ç·šæ¡† (çµ•å°å®šä½ï¼Œæ¯”æ ¼å­å°)
        if(cageId!==-1) {
          const borders = getCageInnerBorders(r,c,cages[cageId]);
          if(borders.top || borders.bottom || borders.left || borders.right) {
            const borderDiv = document.createElement('div');
            borderDiv.className = 'cage-border-inner';
            borderDiv.style.border = 'none';
            if(borders.top)    borderDiv.style.borderTop    = '1.5px dashed #888';
            if(borders.bottom) borderDiv.style.borderBottom = '1.5px dashed #888';
            if(borders.left)   borderDiv.style.borderLeft   = '1.5px dashed #888';
            if(borders.right)  borderDiv.style.borderRight  = '1.5px dashed #888';
            cell.appendChild(borderDiv);
          }
        }

        // ç± å­åŠ ç¸½æ¨™ç¤º
        cages.forEach((cage) => {
          const [cr,cc] = cage.cells[0];
          if(cr===r && cc===c) {
            const label = document.createElement('div');
            label.className = 'sum-label';
            label.innerText = cage.sum;
            cell.appendChild(label);
          }
        });

        // æ•¸å­—ï¼ˆé å¡«æˆ–ç©å®¶å¡«å…¥ï¼‰ï¼Œç”¨ .cell-value åŒ…è£¹ç½®ä¸­
        let numHtml = '';
        if(preFillMap[r][c]) {
          numHtml = `<span class="cell-value pre-fill">${cellValues[r][c]}</span>`;
        } else if(cellValues[r][c]) {
          numHtml = `<span class="cell-value${errorCells[r][c] ? ' error' : ''}">${cellValues[r][c]}</span>`;
        }
        cell.innerHTML += numHtml;

        cell.addEventListener('click', () => {
          if(preFillMap[r][c]) return;
          selectedCell = [r,c];
          renderBoard();
          showNumberPad();
        });
        board.appendChild(cell);
      }
    }
    // å®Œæˆå‹•ç•«åˆ¤æ–·
    if(isFinished(cellValues, answerGrid, preFillMap)) {
      showFinishAnimation();
    }
  }

  function showNumberPad() {
    const pad = document.getElementById('number-pad');
    pad.innerHTML = '';
    pad.style.display = selectedCell ? 'flex' : 'none';
    for(let i=1;i<=9;i++) {
      const btn = document.createElement('button');
      btn.className = 'num-btn';
      btn.textContent = i;
      btn.addEventListener('click', () => {
        if(selectedCell) {
          cellValues[selectedCell[0]][selectedCell[1]] = i;
          selectedCell = null;
          renderBoard();
        }
      });
      pad.appendChild(btn);
    }
    const delBtn = document.createElement('button');
    delBtn.className = 'num-btn del';
    delBtn.textContent = 'æ¸…é™¤';
    delBtn.addEventListener('click', () => {
      if(selectedCell) {
        cellValues[selectedCell[0]][selectedCell[1]] = '';
        selectedCell = null;
        renderBoard();
      }
    });
    pad.appendChild(delBtn);
  }

  // ç”¢ç”Ÿæ–°é¡Œç›®
  document.getElementById("new-btn").onclick = () => {
    const n = parseInt(document.getElementById("pre-fill-input").value,10);
    let num = Math.max(10, Math.min(81, isNaN(n)?25:n));
    newPuzzle(num);
  };

  // é è¨­åˆå§‹åŒ–
  newPuzzle(PRE_FILL_NUM);

</script>
</html>